import XCTest
import SwiftUI
@testable import Archery

/// Integration tests that verify the @Localizable macro generates working code
/// rather than testing exact string matching of the generated code
final class LocalizableIntegrationTests: XCTestCase {
    
    override func setUp() {
        super.setUp()
        LocalizationEngine.shared.reset()
    }
    
    override func tearDown() {
        LocalizationEngine.shared.reset()
        super.tearDown()
    }
    
    func testLocalizableEnumGeneratesWorkingCode() {
        // This simulates what would be generated by @Localizable
        enum TestStrings: String, LocalizationKey {
            case welcome
            case goodbye
            
            var key: String {
                switch self {
                case .welcome: return "TestStrings.welcome"
                case .goodbye: return "TestStrings.goodbye"
                }
            }
            
            var defaultValue: String {
                switch self {
                case .welcome: return "Welcome"
                case .goodbye: return "Goodbye"
                }
            }
            
            var tableName: String? { "TestStrings" }
            var comment: String { "Test string" }
        }
        
        // Test that the generated code works
        XCTAssertEqual(TestStrings.welcome.key, "TestStrings.welcome")
        XCTAssertEqual(TestStrings.goodbye.key, "TestStrings.goodbye")
        
        XCTAssertEqual(TestStrings.welcome.defaultValue, "Welcome")
        XCTAssertEqual(TestStrings.goodbye.defaultValue, "Goodbye")
        
        XCTAssertEqual(TestStrings.welcome.rawValue, "welcome")
        XCTAssertEqual(TestStrings.goodbye.rawValue, "goodbye")
    }
    
    func testLocalizableWithPseudoLocalization() {
        enum AppStrings: String, LocalizationKey {
            case buttonSubmit
            case errorNetworkUnavailable
            
            var key: String {
                switch self {
                case .buttonSubmit: return "AppStrings.buttonSubmit"
                case .errorNetworkUnavailable: return "AppStrings.errorNetworkUnavailable"
                }
            }
            
            var defaultValue: String {
                switch self {
                case .buttonSubmit: return "Submit"
                case .errorNetworkUnavailable: return "Network Unavailable"
                }
            }
            
            var tableName: String? { "AppStrings" }
            var comment: String { "App string" }
        }
        
        // Test normal mode
        LocalizationEngine.shared.setMode(.normal)
        let normalText = LocalizationEngine.shared.transform(AppStrings.buttonSubmit.defaultValue)
        XCTAssertEqual(normalText, "Submit")
        
        // Test pseudo mode
        LocalizationEngine.shared.setMode(.pseudo)
        let pseudoText = LocalizationEngine.shared.transform(AppStrings.buttonSubmit.defaultValue)
        XCTAssertTrue(pseudoText.hasPrefix("["))
        XCTAssertTrue(pseudoText.hasSuffix("]"))
        XCTAssertTrue(pseudoText.contains("ü"))
        
        // Test RTL mode
        LocalizationEngine.shared.setMode(.rtl)
        let rtlText = LocalizationEngine.shared.transform(AppStrings.errorNetworkUnavailable.defaultValue)
        XCTAssertTrue(rtlText.contains("\u{202E}"))
        
        // Test double length mode
        LocalizationEngine.shared.setMode(.doubleLength)
        let doubleText = LocalizationEngine.shared.transform(AppStrings.buttonSubmit.defaultValue)
        XCTAssertEqual(doubleText, "Submit Submit")
        
        // Test accented mode
        LocalizationEngine.shared.setMode(.accented)
        let accentedText = LocalizationEngine.shared.transform("Hello")
        XCTAssertTrue(accentedText.contains("é"))
    }
    
    func testStringExtraction() {
        LocalizationEngine.shared.reset()
        
        // Simulate what the macro would generate
        #if DEBUG
        let _ = {
            LocalizationEngine.shared.recordExtractedString(
                ExtractedString(
                    key: "TestEnum.testCase",
                    defaultValue: "Test Case",
                    comment: "Localized string for testCase",
                    tableName: "TestEnum"
                )
            )
        }()
        #endif
        
        let extracted = LocalizationEngine.shared.getExtractedStrings()
        XCTAssertTrue(extracted.contains(where: { $0.key == "TestEnum.testCase" }))
    }
    
    func testMissingKeyDetection() {
        LocalizationEngine.shared.reset()
        
        // Simulate missing key detection
        #if DEBUG
        LocalizationEngine.shared.recordMissingKey("undefined.key.test")
        #endif
        
        let missing = LocalizationEngine.shared.getMissingKeys()
        XCTAssertTrue(missing.contains("undefined.key.test"))
    }
    
    func testStringsFileGeneration() {
        LocalizationEngine.shared.reset()
        
        // Record some strings
        LocalizationEngine.shared.recordExtractedString(
            ExtractedString(
                key: "app.name",
                defaultValue: "My App",
                comment: "Application name",
                tableName: "Main"
            )
        )
        
        LocalizationEngine.shared.recordExtractedString(
            ExtractedString(
                key: "app.version",
                defaultValue: "Version 1.0",
                comment: "Version string",
                tableName: "Main"
            )
        )
        
        let stringsFile = LocalizationEngine.shared.generateStringsFile(tableName: "Main")
        
        XCTAssertTrue(stringsFile.contains("\"app.name\" = \"My App\""))
        XCTAssertTrue(stringsFile.contains("\"app.version\" = \"Version 1.0\""))
        XCTAssertTrue(stringsFile.contains("Application name"))
        XCTAssertTrue(stringsFile.contains("Version string"))
    }
    
    func testLocalizationWithSwiftUIText() {
        enum UIStrings: String, LocalizationKey {
            case title
            case subtitle
            
            var key: String {
                switch self {
                case .title: return "UIStrings.title"
                case .subtitle: return "UIStrings.subtitle"
                }
            }
            
            var defaultValue: String {
                switch self {
                case .title: return "Main Title"
                case .subtitle: return "Subtitle Text"
                }
            }
            
            var tableName: String? { "UIStrings" }
            var comment: String { "UI string" }
        }
        
        // Test that it works with SwiftUI Text
        let localizedString = LocalizedString(
            key: UIStrings.title.key,
            tableName: UIStrings.title.tableName,
            comment: UIStrings.title.comment
        )
        
        XCTAssertEqual(localizedString.key, "UIStrings.title")
        XCTAssertEqual(localizedString.tableName, "UIStrings")
        
        // Test with arguments
        let formattedString = LocalizedString(
            key: "greeting",
            arguments: ["World"]
        )
        
        // The actual formatting would happen in localized()
        XCTAssertNotNil(formattedString)
    }
    
    func testLocalizableEnumConformance() {
        // Verify that generated enums properly conform to LocalizationKey
        struct TestConformance<T: LocalizationKey> {
            let value: T
            
            func testProtocolRequirements() -> Bool {
                _ = value.key
                _ = value.tableName
                _ = value.bundle
                _ = value.comment
                return true
            }
        }
        
        enum ConformingEnum: String, LocalizationKey {
            case test
        }
        
        let test = TestConformance(value: ConformingEnum.test)
        XCTAssertTrue(test.testProtocolRequirements())
    }
    
    func testResetFunctionality() {
        // Add some data
        LocalizationEngine.shared.recordMissingKey("test.key")
        LocalizationEngine.shared.recordExtractedString(
            ExtractedString(key: "test", defaultValue: "Test", comment: "Test")
        )
        LocalizationEngine.shared.setMode(.pseudo)
        
        // Reset
        LocalizationEngine.shared.reset()
        
        // Verify reset worked
        XCTAssertTrue(LocalizationEngine.shared.getMissingKeys().isEmpty)
        XCTAssertTrue(LocalizationEngine.shared.getExtractedStrings().isEmpty)
        XCTAssertEqual(LocalizationEngine.shared.getMode(), .normal)
    }
}