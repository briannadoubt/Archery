public class PlayerStore {
}

public protocol PlayerStoreProtocol: Sendable {
    // CRUD operations
    func fetchAll() async throws -> [Player]
    func fetch(id: Player.ID) async throws -> Player?
    func insert(_ record: Player) async throws -> Player
    func update(_ record: Player) async throws
    func upsert(_ record: Player) async throws -> Player
    func delete(id: Player.ID) async throws -> Bool
    func deleteAll() async throws -> Int
    func count() async throws -> Int
}

public final class PlayerStoreLive: PlayerStoreProtocol, @unchecked Sendable {
    private let container: Archery.PersistenceContainer
    private let base: PlayerStore
    private let entityTypeName = "Player"
    private let tableName = "players"

    public init(container: Archery.PersistenceContainer) {
        self.container = container
        self.base = PlayerStore()
    }

    public init(envContainer: Archery.EnvContainer) {
        guard let persistenceContainer = envContainer.grdb else {
            fatalError("PersistenceContainer not registered in EnvContainer")
        }
        self.container = persistenceContainer
        self.base = PlayerStore()
    }

    // CRUD operations with performance tracing

    public func fetchAll() async throws -> [Player] {
        try await Archery.OperationTracer.traceDatabase("fetchAll", table: tableName) {
            let start = ContinuousClock.now
            let results = try await container.read { db in
                try Player.fetchAll(db)
            }
            let duration = ContinuousClock.now - start
            let durationMs = Double(duration.components.attoseconds) / 1_000_000_000_000_000

            // Auto-track fetch
            await MainActor.run {
                ArcheryAnalyticsConfiguration.shared.track(
                    .entityFetched(entityType: entityTypeName, count: results.count, durationMs: durationMs)
                )
            }

            return results
        }
    }

    public func fetch(id: Player.ID) async throws -> Player? {
        try await Archery.OperationTracer.traceDatabase("fetch", table: tableName) {
            try await container.read { db in
                try Player.fetchOne(db, id: id)
            }
        }
    }

    public func insert(_ record: Player) async throws -> Player {
        try await Archery.OperationTracer.traceDatabase("insert", table: tableName) {
            let result = try await container.write { db in
                var record = record
                try record.insert(db)
                return record
            }

            // Auto-track entity created
            await MainActor.run {
                ArcheryAnalyticsConfiguration.shared.track(
                    .entityCreated(entityType: entityTypeName, entityId: String(describing: result.id))
                )
            }

            return result
        }
    }

    public func update(_ record: Player) async throws {
        try await Archery.OperationTracer.traceDatabase("update", table: tableName) {
            try await container.write { db in
                try record.update(db)
            }

            // Auto-track entity updated
            await MainActor.run {
                ArcheryAnalyticsConfiguration.shared.track(
                    .entityUpdated(entityType: entityTypeName, entityId: String(describing: record.id))
                )
            }
        }
    }

    public func upsert(_ record: Player) async throws -> Player {
        try await Archery.OperationTracer.traceDatabase("upsert", table: tableName) {
            let result = try await container.write { db in
                var record = record
                try record.save(db)
                return record
            }

            // Auto-track entity created/updated (upsert)
            await MainActor.run {
                ArcheryAnalyticsConfiguration.shared.track(
                    .entityUpdated(entityType: entityTypeName, entityId: String(describing: result.id))
                )
            }

            return result
        }
    }

    public func delete(id: Player.ID) async throws -> Bool {
        try await Archery.OperationTracer.traceDatabase("delete", table: tableName) {
            let deleted = try await container.write { db in
                try Player.deleteOne(db, id: id)
            }

            if deleted {
                // Auto-track entity deleted
                await MainActor.run {
                    ArcheryAnalyticsConfiguration.shared.track(
                        .entityDeleted(entityType: entityTypeName, entityId: String(describing: id))
                    )
                }
            }

            return deleted
        }
    }

    public func deleteAll() async throws -> Int {
        try await Archery.OperationTracer.traceDatabase("deleteAll", table: tableName) {
            try await container.write { db in
                try Player.deleteAll(db)
            }
        }
    }

    public func count() async throws -> Int {
        try await Archery.OperationTracer.traceDatabase("count", table: tableName) {
            try await container.read { db in
                try Player.fetchCount(db)
            }
        }
    }
}

public final class MockPlayerStore: PlayerStoreProtocol, @unchecked Sendable {
    // CRUD handlers
    public var fetchAllHandler: () async throws -> [Player] = {
        []
    }
    public var fetchHandler: (Player.ID) async throws -> Player? = { _ in
        nil
    }
    public var insertHandler: (Player) async throws -> Player = {
        $0
    }
    public var updateHandler: (Player) async throws -> Void = { _ in
    }
    public var upsertHandler: (Player) async throws -> Player = {
        $0
    }
    public var deleteHandler: (Player.ID) async throws -> Bool = { _ in
        true
    }
    public var deleteAllHandler: () async throws -> Int = {
        0
    }
    public var countHandler: () async throws -> Int = {
        0
    }

    public init() {
    }

    // CRUD operations

    public func fetchAll() async throws -> [Player] {
        try await fetchAllHandler()
    }

    public func fetch(id: Player.ID) async throws -> Player? {
        try await fetchHandler(id)
    }

    public func insert(_ record: Player) async throws -> Player {
        try await insertHandler(record)
    }

    public func update(_ record: Player) async throws {
        try await updateHandler(record)
    }

    public func upsert(_ record: Player) async throws -> Player {
        try await upsertHandler(record)
    }

    public func delete(id: Player.ID) async throws -> Bool {
        try await deleteHandler(id)
    }

    public func deleteAll() async throws -> Int {
        try await deleteAllHandler()
    }

    public func count() async throws -> Int {
        try await countHandler()
    }
}
