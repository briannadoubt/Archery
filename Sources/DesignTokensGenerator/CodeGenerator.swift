import Foundation

// MARK: - Code Generator

/// Generates Swift code from design token manifests.
struct CodeGenerator {

    // MARK: - Public API

    static func generate(
        manifest: ManifestParser.Manifest,
        enumName: String,
        accessLevel: String
    ) -> String {
        let access = accessLevel.isEmpty ? "" : "\(accessLevel) "

        let colorEnum = makeEnum(
            access: access,
            name: "ColorToken",
            cases: manifest.colors.keys.sorted()
        )

        let typographyEnum = makeEnum(
            access: access,
            name: "TypographyToken",
            cases: manifest.typography.keys.sorted()
        )

        let spacingEnum = makeEnum(
            access: access,
            name: "SpacingToken",
            cases: manifest.spacing.keys.sorted()
        )

        let themeBuilder = makeThemeBuilder(
            name: enumName,
            access: access,
            manifest: manifest
        )

        return """
        // Generated by DesignTokensPlugin - DO NOT EDIT
        // Re-run build to regenerate from design-tokens.json

        import SwiftUI
        import Archery

        \(access)enum \(enumName): DesignTokenSet {
        \(colorEnum)

        \(typographyEnum)

        \(spacingEnum)

            \(access)static let name = "\(enumName)"

        \(themeBuilder)
        }
        """
    }

    // MARK: - Private Helpers

    private static func makeEnum(access: String, name: String, cases: [String]) -> String {
        let joined = cases.map { "        case \($0.safeIdentifier)" }.joined(separator: "\n")
        return """
            \(access)enum \(name): String, CaseIterable, Sendable {
        \(joined)
            }
        """
    }

    private static func makeThemeBuilder(
        name: String,
        access: String,
        manifest: ManifestParser.Manifest
    ) -> String {
        let colorLines = manifest.colors.sorted(by: { $0.key < $1.key }).map { key, value in
            let dark = value.dark ?? value.light
            let high = value.highContrast ?? dark
            return "            \"\(key)\": ArcheryTheme.resolvedColor(variant: variant, light: \"\(value.light)\", dark: \"\(dark)\", highContrast: \"\(high)\")"
        }.joined(separator: ",\n")

        let colorHex = manifest.colors.sorted(by: { $0.key < $1.key }).map { key, value in
            let dark = value.dark ?? value.light
            let high = value.highContrast ?? dark
            return "            \"\(key)\": ArcheryTheme.resolvedHex(variant: variant, light: \"\(value.light)\", dark: \"\(dark)\", highContrast: \"\(high)\")"
        }.joined(separator: ",\n")

        let typographyLines = manifest.typography
            .sorted(by: { $0.key < $1.key })
            .map { key, value in
                let design = value.design.map { ".\($0)" } ?? ".default"
                let lineHeightValue = value.lineHeight.map { "\($0)" } ?? "nil"
                return "            \"\(key)\": TypographyStyle(size: \(value.size), weight: \(weight(for: value.weight)), lineHeight: \(lineHeightValue), design: \(design))"
            }

        let spacingLines = manifest.spacing
            .sorted(by: { $0.key < $1.key })
            .map { key, value in
                "            \"\(key)\": \(value)"
            }

        return """
            \(access)static func theme(for variant: ThemeVariant) -> ArcheryTheme {
                let colors: [String: SwiftUI.Color] = [
        \(colorLines)
                ]

                let colorHex: [String: String] = [
        \(colorHex)
                ]

                let typography: [String: TypographyStyle] = [
        \(typographyLines.joined(separator: ",\n"))
                ]

                let spacing: [String: CGFloat] = [
        \(spacingLines.joined(separator: ",\n"))
                ]

                return ArcheryTheme(
                    name: "\(name)",
                    variant: variant,
                    colors: colors,
                    colorHex: colorHex,
                    typography: typography,
                    spacing: spacing
                )
            }
        """
    }

    private static func weight(for input: String) -> String {
        switch input.lowercased() {
        case "ultralight": return "SwiftUI.Font.Weight.ultraLight"
        case "thin": return "SwiftUI.Font.Weight.thin"
        case "light": return "SwiftUI.Font.Weight.light"
        case "regular": return "SwiftUI.Font.Weight.regular"
        case "medium": return "SwiftUI.Font.Weight.medium"
        case "semibold", "semi-bold": return "SwiftUI.Font.Weight.semibold"
        case "bold": return "SwiftUI.Font.Weight.bold"
        case "heavy": return "SwiftUI.Font.Weight.heavy"
        case "black": return "SwiftUI.Font.Weight.black"
        default: return "SwiftUI.Font.Weight.regular"
        }
    }
}

// MARK: - String Extension

private extension String {
    var safeIdentifier: String {
        let cleaned = replacingOccurrences(of: "-", with: "_")
        if cleaned.first?.isNumber == true { return "_" + cleaned }
        return cleaned
    }
}
