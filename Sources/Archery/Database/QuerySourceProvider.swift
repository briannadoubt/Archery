import Foundation
import SwiftUI

// MARK: - Query Source Provider Protocol

/// Protocol for types that provide query sources.
///
/// Conformance is typically generated by the `@QuerySources` macro.
/// Each provider groups related queries for a specific model/domain.
///
/// Example:
/// ```swift
/// extension Task {
///     @QuerySources
///     struct Sources {
///         let api: TasksAPIProtocol
///
///         var all: QuerySource<Task> { ... }
///         var completed: QuerySource<Task> { ... }
///     }
/// }
/// ```
public protocol QuerySourceProvider {}

// MARK: - Has Query Sources Protocol

/// Protocol for model types that have associated query sources.
///
/// Conformance enables shorthand keypath syntax in `@Query`:
/// ```swift
/// // Instead of: @Query(\Task.Sources.all)
/// @Query(\.all)
/// var tasks: [Task]
/// ```
///
/// Conformance is automatically generated by `@QuerySources` when
/// the Sources struct is nested inside a model type.
public protocol HasQuerySources: Sendable {
    /// The type providing query sources for this model
    associatedtype Sources: QuerySourceProvider & Sendable
}

// MARK: - Query Source Registry

/// Registry for storing and resolving query source providers.
///
/// The registry is injected via SwiftUI environment and allows
/// `@Query` property wrappers to resolve keypaths to their providers.
@MainActor
@Observable
public final class QuerySourceRegistry {
    /// Shared singleton instance
    public static let shared = QuerySourceRegistry()

    /// Storage for registered providers, keyed by type
    private var providers: [ObjectIdentifier: Any] = [:]

    public init() {}

    /// Register a query source provider
    /// - Parameter provider: The provider instance to register
    public func register<P: QuerySourceProvider>(_ provider: P) {
        providers[ObjectIdentifier(P.self)] = provider
    }

    /// Resolve a query source provider by type
    /// - Parameter type: The provider type to resolve
    /// - Returns: The registered provider, or nil if not found
    public func resolve<P: QuerySourceProvider>(_ type: P.Type) -> P? {
        providers[ObjectIdentifier(P.self)] as? P
    }

    /// Resolve a query source provider by type identifier (for type-erased access)
    /// - Parameter type: The provider type to resolve
    /// - Returns: The registered provider as Any, or nil if not found
    public func resolveByType(_ type: Any.Type) -> Any? {
        providers[ObjectIdentifier(type)]
    }

    /// Check if a provider type is registered
    /// - Parameter type: The provider type to check
    /// - Returns: True if the provider is registered
    public func isRegistered<P: QuerySourceProvider>(_ type: P.Type) -> Bool {
        providers[ObjectIdentifier(P.self)] != nil
    }

    /// Remove a registered provider
    /// - Parameter type: The provider type to remove
    public func unregister<P: QuerySourceProvider>(_ type: P.Type) {
        providers.removeValue(forKey: ObjectIdentifier(P.self))
    }

    /// Remove all registered providers
    public func clear() {
        providers.removeAll()
    }

    /// Register all known query source providers.
    /// This is called automatically by GeneratedAppDatabase during setup.
    /// Types with @QuerySources conformance should call register() during app initialization.
    public func registerAll() {
        // Query sources are registered by individual types via register()
        // This method exists as a hook for future automatic discovery
    }
}

// MARK: - Environment Integration

/// Environment key for the query source registry
private struct QuerySourceRegistryKey: @preconcurrency EnvironmentKey {
    @MainActor static let defaultValue = QuerySourceRegistry.shared
}

public extension EnvironmentValues {
    /// The query source registry for resolving `@Query` keypaths
    var querySourceRegistry: QuerySourceRegistry {
        get { self[QuerySourceRegistryKey.self] }
        set { self[QuerySourceRegistryKey.self] = newValue }
    }
}

// MARK: - View Modifier

/// View modifier for injecting query source providers into the environment
struct QuerySourcesModifier<P: QuerySourceProvider & Sendable>: ViewModifier {
    let provider: P

    func body(content: Content) -> some View {
        // Register synchronously so @Query can resolve immediately
        // Uses shared registry since it's the default for querySourceRegistry
        let _ = MainActor.assumeIsolated {
            QuerySourceRegistry.shared.register(provider)
        }
        return content
    }
}

public extension View {
    /// Inject a query source provider into the environment.
    ///
    /// Multiple providers can be injected by chaining this modifier:
    /// ```swift
    /// ContentView()
    ///     .querySources(TaskSources(api: TasksAPI.live()))
    ///     .querySources(UserSources(api: UsersAPI.live()))
    /// ```
    ///
    /// - Parameter provider: The query source provider to inject
    /// - Returns: A view with the provider registered in the query source registry
    func querySources<P: QuerySourceProvider & Sendable>(_ provider: P) -> some View {
        modifier(QuerySourcesModifier(provider: provider))
    }
}

// MARK: - Query Source Resolution

/// Helper for resolving query sources from keypaths
public enum QuerySourceResolver {
    /// Resolve a query source from a keypath on a provider
    /// - Parameters:
    ///   - keyPath: The keypath to the query source property
    ///   - registry: The registry to resolve the provider from
    /// - Returns: The resolved query source, or nil if provider not found
    @MainActor
    public static func resolve<Provider: QuerySourceProvider, Element>(
        _ keyPath: KeyPath<Provider, QuerySource<Element>>,
        from registry: QuerySourceRegistry
    ) -> QuerySource<Element>? {
        guard let provider = registry.resolve(Provider.self) else {
            return nil
        }
        return provider[keyPath: keyPath]
    }

    /// Resolve a parameterized query source from a keypath on a provider
    /// - Parameters:
    ///   - keyPath: The keypath to the parameterized query source property
    ///   - param: The parameter to pass to the query source function
    ///   - registry: The registry to resolve the provider from
    /// - Returns: The resolved query source, or nil if provider not found
    @MainActor
    public static func resolve<Provider: QuerySourceProvider, Element, Param>(
        _ keyPath: KeyPath<Provider, (Param) -> QuerySource<Element>>,
        param: Param,
        from registry: QuerySourceRegistry
    ) -> QuerySource<Element>? {
        guard let provider = registry.resolve(Provider.self) else {
            return nil
        }
        let factory = provider[keyPath: keyPath]
        return factory(param)
    }
}
