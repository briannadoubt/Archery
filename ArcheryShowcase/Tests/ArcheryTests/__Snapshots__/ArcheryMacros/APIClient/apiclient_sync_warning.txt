class SyncAPI {
    func ping() -> Bool { true }
}

protocol SyncAPIProtocol {
    func ping() -> Bool
}

final class SyncAPILive: SyncAPIProtocol, @unchecked Sendable {
    private let base: BaseBox
    private let cachePolicy: APICachePolicy
    private let retryPolicy: APIRetryPolicy
    private let decoding: APIDecodingConfiguration
    private let decoder: JSONDecoder
    private let clock = ContinuousClock()
    struct BaseBox: @unchecked Sendable {
        let value: SyncAPI
    }
    struct Box: @unchecked Sendable {
        let value: Any
    }
    private let state = State()

    actor State {
        struct CacheEntry {
            let value: Box
            let expiry: ContinuousClock.Instant?
        }

        private var cache: [String: CacheEntry] = [:]

        func cachedValue(for key: String, now: ContinuousClock.Instant) -> Box? {
            guard let entry = cache[key] else {
                return nil
            }
            if let expiry = entry.expiry, expiry < now {
                cache[key] = nil
                return nil
            }
            return entry.value
        }
        func setCached(_ value: Box, for key: String, expiry: ContinuousClock.Instant?) {
            cache[key] = CacheEntry(value: value, expiry: expiry)
        }
    }

    init(
        baseFactory: @escaping () -> SyncAPI = {
            SyncAPI()
        },
        retryPolicy: APIRetryPolicy = .default,
        decoding: APIDecodingConfiguration = .default,
        cachePolicy: APICachePolicy = .disabled
    ) {
        self.base = BaseBox(value: baseFactory())
        self.retryPolicy = retryPolicy
        self.decoding = decoding
        self.decoder = decoding.makeDecoder()
        self.cachePolicy = cachePolicy
    }

    private func withRetry<T>(
        function: String,
        operation: @escaping @Sendable () async throws -> T
    ) async throws -> T {
        var attempt = 0
        var lastError: Error?

        while attempt <= retryPolicy.maxRetries {
            if Task.isCancelled {
                throw CancellationError()
            }
            do {
                return try await operation()
            } catch {
                if !retryPolicy.shouldRetry(error) {
                    // Auto-track API error
                    await MainActor.run {
                        ArcheryErrorTracker.trackNetworkError(error, endpoint: function)
                    }
                    throw error
                }
                lastError = error
                if attempt == retryPolicy.maxRetries {
                    break
                }
                let delay = retryPolicy.delay(for: attempt)
                try? await Task.sleep(for: delay)
            }
            attempt += 1
        }

        let finalError = lastError ?? URLError(.unknown)
        // Auto-track API error after all retries exhausted
        await MainActor.run {
            ArcheryErrorTracker.trackNetworkError(finalError, endpoint: function)
        }
        throw finalError
    }

    func decode<T: Decodable>(_ data: Data, as type: T.Type = T.self) throws -> T {
        try decoder.decode(T.self, from: data)
    }

    func ping() -> Bool {
        let result = self.base.value.ping()
        return result
    }

    static func live(
        cachePolicy: APICachePolicy = .disabled,
        retryPolicy: APIRetryPolicy = .default,
        decoding: APIDecodingConfiguration = .default
    ) -> SyncAPIProtocol {
        SyncAPILive(
            baseFactory: {
                SyncAPI()
            },
            retryPolicy: retryPolicy,
            decoding: decoding,
            cachePolicy: cachePolicy
        )
    }

    static func make(
        in container: EnvContainer,
        cachePolicy: APICachePolicy = .disabled,
        retryPolicy: APIRetryPolicy = .default,
        decoding: APIDecodingConfiguration = .default
    ) -> SyncAPIProtocol {
        if let cached: SyncAPIProtocol = container.resolve() {
            return cached
        }
        let client = live(
            cachePolicy: cachePolicy,
            retryPolicy: retryPolicy,
            decoding: decoding
        )
        container.register(client as SyncAPIProtocol)
        return client
    }

    static func makeChild(
        from container: EnvContainer,
        cachePolicy: APICachePolicy = .disabled,
        retryPolicy: APIRetryPolicy = .default,
        decoding: APIDecodingConfiguration = .default
    ) -> SyncAPIProtocol {
        let child = EnvContainer()
        container.merge(into: child)
        let client = live(
            cachePolicy: cachePolicy,
            retryPolicy: retryPolicy,
            decoding: decoding
        )
        child.register(client as SyncAPIProtocol)
        return client
    }
}

final class MockSyncAPI: SyncAPIProtocol {
    var pingHandler: (() -> Bool)?

    init() {
    }

    func ping() -> Bool {
        if let handler = pingHandler {
            return handler()
        }
        fatalError("Not implemented in mock")
    }
}