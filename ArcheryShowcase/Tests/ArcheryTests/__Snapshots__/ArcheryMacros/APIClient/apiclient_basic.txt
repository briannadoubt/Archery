class WeatherAPI {
    func forecast(city: String) async throws -> Data { Data() }
}

protocol WeatherAPIProtocol {
    func forecast(city: String) async throws -> Data
}

final class WeatherAPILive: WeatherAPIProtocol, @unchecked Sendable {
    private let base: BaseBox
    private let cachePolicy: APICachePolicy
    private let retryPolicy: APIRetryPolicy
    private let decoding: APIDecodingConfiguration
    private let decoder: JSONDecoder
    private let clock = ContinuousClock()
    struct BaseBox: @unchecked Sendable {
        let value: WeatherAPI
    }
    struct Box: @unchecked Sendable {
        let value: Any
    }
    private let state = State()

    actor State {
        struct CacheEntry {
            let value: Box
            let expiry: ContinuousClock.Instant?
        }

        private var cache: [String: CacheEntry] = [:]

        func cachedValue(for key: String, now: ContinuousClock.Instant) -> Box? {
            guard let entry = cache[key] else {
                return nil
            }
            if let expiry = entry.expiry, expiry < now {
                cache[key] = nil
                return nil
            }
            return entry.value
        }
        func setCached(_ value: Box, for key: String, expiry: ContinuousClock.Instant?) {
            cache[key] = CacheEntry(value: value, expiry: expiry)
        }
    }

    init(
        baseFactory: @escaping () -> WeatherAPI = {
            WeatherAPI()
        },
        retryPolicy: APIRetryPolicy = .default,
        decoding: APIDecodingConfiguration = .default,
        cachePolicy: APICachePolicy = .disabled
    ) {
        self.base = BaseBox(value: baseFactory())
        self.retryPolicy = retryPolicy
        self.decoding = decoding
        self.decoder = decoding.makeDecoder()
        self.cachePolicy = cachePolicy
    }

    private func withRetry<T>(
        function: String,
        operation: @escaping @Sendable () async throws -> T
    ) async throws -> T {
        var attempt = 0
        var lastError: Error?

        while attempt <= retryPolicy.maxRetries {
            if Task.isCancelled {
                throw CancellationError()
            }
            do {
                return try await operation()
            } catch {
                if !retryPolicy.shouldRetry(error) {
                    // Auto-track API error
                    await MainActor.run {
                        ArcheryErrorTracker.trackNetworkError(error, endpoint: function)
                    }
                    throw error
                }
                lastError = error
                if attempt == retryPolicy.maxRetries {
                    break
                }
                let delay = retryPolicy.delay(for: attempt)
                try? await Task.sleep(for: delay)
            }
            attempt += 1
        }

        let finalError = lastError ?? URLError(.unknown)
        // Auto-track API error after all retries exhausted
        await MainActor.run {
            ArcheryErrorTracker.trackNetworkError(finalError, endpoint: function)
        }
        throw finalError
    }

    func decode<T: Decodable>(_ data: Data, as type: T.Type = T.self) throws -> T {
        try decoder.decode(T.self, from: data)
    }

    func forecast(city: String) async throws -> Data {
        let policy = cachePolicy
        let key = "forecast|" + [String(describing: city)].joined(separator: "|")
        if policy.enabled, let cached = await state.cachedValue(for: key, now: clock.now)?.value as? Data {
            return cached
        }
        let result = try await withRetry(function: "forecast(city: String)") {
            try await self.base.value.forecast(city: city)
        }
        if policy.enabled {
            let expiry = policy.ttl.map {
                clock.now.advanced(by: $0)
            }
            await state.setCached(Box(value: result), for: key, expiry: expiry)
        }
        return result
    }

    static func live(
        cachePolicy: APICachePolicy = .disabled,
        retryPolicy: APIRetryPolicy = .default,
        decoding: APIDecodingConfiguration = .default
    ) -> WeatherAPIProtocol {
        WeatherAPILive(
            baseFactory: {
                WeatherAPI()
            },
            retryPolicy: retryPolicy,
            decoding: decoding,
            cachePolicy: cachePolicy
        )
    }

    static func make(
        in container: EnvContainer,
        cachePolicy: APICachePolicy = .disabled,
        retryPolicy: APIRetryPolicy = .default,
        decoding: APIDecodingConfiguration = .default
    ) -> WeatherAPIProtocol {
        if let cached: WeatherAPIProtocol = container.resolve() {
            return cached
        }
        let client = live(
            cachePolicy: cachePolicy,
            retryPolicy: retryPolicy,
            decoding: decoding
        )
        container.register(client as WeatherAPIProtocol)
        return client
    }

    static func makeChild(
        from container: EnvContainer,
        cachePolicy: APICachePolicy = .disabled,
        retryPolicy: APIRetryPolicy = .default,
        decoding: APIDecodingConfiguration = .default
    ) -> WeatherAPIProtocol {
        let child = EnvContainer()
        container.merge(into: child)
        let client = live(
            cachePolicy: cachePolicy,
            retryPolicy: retryPolicy,
            decoding: decoding
        )
        child.register(client as WeatherAPIProtocol)
        return client
    }
}

final class MockWeatherAPI: WeatherAPIProtocol {
    var forecastHandler: ((String) async throws -> Data)?

    init() {
    }

    func forecast(city: String) async throws -> Data {
        if let handler = forecastHandler {
            return try await handler(city)
        }
        fatalError("Not implemented in mock")
    }
}